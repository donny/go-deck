<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Have a go</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', include the PDF print sheet -->
		<script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = 'css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section data-background="#007777">
					<h1>Have a go</h1>
					<h3>http://golang.org</h3>
					<p>
						<small>Donny Kurniawan</small>
					</p>
				</section>

				<section data-background="#007777">
					<h2>Go</h2>
					<p>
						Go, also called golang, is a statically-typed language with syntax loosely derived from that of C, adding garbage collected memory management, type safety, some dynamic-typing capabilities, additional built-in types such as variable-length arrays and key-value maps.
					</p>
				</section>

				<section data-background="#007777">
					<section>
						<h2>Hello World</h2>
						<pre><code data-trim>
package main

func main() {
	print("Hello world.")
}

						</code></pre>
					</section>

					<section>
						<pre><code data-trim>
Hello world.
						</code></pre>
					</section>
				</section>

				<section data-background="#007777">
					<h2>Go Fmt</h2>
					<p>
						Formats your code according to the standard style covering indentation, spacing, and many other details.
					</p>
					<p>
						<small>Demo</small>
					</p>
				</section>

				<section>
					<section>
						<h2>Packages and imports</h2>
						<pre><code data-trim>
package main

import (
	"fmt"
	"reflect"
)

// import "fmt"
// import "reflect"

func main() {
	fmt.Printf("Type: %s", reflect.TypeOf("hello"))
}
						</code></pre>
					</section>

					<section>
						<pre><code data-trim>
Type: string
						</code></pre>
					</section>
				</section>

				<section>
					<section>
						<h2>Functions</h2>
						<pre><code data-trim>
package main

import "fmt"

func add(x int, y int) int {
	return x + y
}

func main() {
	fmt.Println(add(42, 13))
}

						</code></pre>
					</section>

					<section>
						<pre><code data-trim>
55
						</code></pre>
					</section>

					<section>
						<h2>Functions</h2>
						<pre><code data-trim>
package main

import "fmt"

func add(x, y int) (int, string) {
	return x + y, "OK"
}

func main() {
	fmt.Println(add(42, 13))
}

						</code></pre>
					</section>

					<section>
						<pre><code data-trim>
55 OK
						</code></pre>
					</section>

					<section>
						<h2>Functions</h2>
						<pre><code data-trim>
package main

import "fmt"

func add(x, y int) (result int, status string) {
	result = x + y
	status = "OK"
	return
}

func main() {
	fmt.Println(add(42, 13))
}

						</code></pre>
					</section>

					<section>
						<pre><code data-trim>
55 OK
						</code></pre>
					</section>

					<section>
						<h2>Functions</h2>
						<pre><code data-trim>
package main

import "fmt"

func add(x, y int) int {
	realadd := func(x, y int) int {
		return x + y
	}

	return realadd(x, y)
}

func main() {
	fmt.Println(add(42, 13))
}

						</code></pre>
					</section>

					<section>
						<pre><code data-trim>
55
						</code></pre>
					</section>
				</section>

				<section>
					<h2>Types</h2>
					<ul>
						<li>bool</li>
						<li>string</li>
						<li>int int8 int16 int32 int64</li>
						<li>uint uint8 uint16 uint32 uint64 uintptr</li>
						<li>byte (uint8)</li>
						<li>rune (int32)</li>
						<li>float32 float64</li>
						<li>complex64 complex128</li>
					</ul>
				</section>

				<section>
					<section>
						<h2>Variables</h2>
						<pre><code data-trim>
package main

func main() {
	var i int = 42
	var f float64 = float64(i)

	ix := 43
	fx := 43.0

	println(i, f)
	println(ix, fx)
}

						</code></pre>
					</section>

					<section>
						<pre><code data-trim>
42 +4.200000e+001
43 +4.300000e+001
						</code></pre>
					</section>
				</section>

				<section>
					<section>
						<h2>For Loop</h2>
						<pre><code data-trim>
package main

func main() {
	sum := 0
	for i := 0; i < 3; i++ {
		sum += i
	}

	print(sum)
}


						</code></pre>
					</section>

					<section>
						<pre><code data-trim>
3
						</code></pre>
					</section>

					<section>
						<h2>For Loop</h2>
						<pre><code data-trim>
package main

func main() {
	sum := 1
	for sum < 3 {
		sum += 1
	}

	print(sum)
}


						</code></pre>
					</section>

					<section>
						<pre><code data-trim>
3
						</code></pre>
					</section>
				</section>

				<section>
					<section>
						<h2>If Else</h2>
						<pre><code data-trim>
package main

func main() {
	answer := 42

	if answer != 42 {
		print("false")
	} else {
		print("true")
	}
}

						</code></pre>
					</section>

					<section>
						<pre><code data-trim>
true
						</code></pre>
					</section>

					<section>
						<h2>If Else</h2>
						<pre><code data-trim>
package main

func main() {
	answer := 42

	if status := "ok"; answer != 42 {
		println("false")
		println(status)
	} else {
		println("true")
		println(status)
	}
}

						</code></pre>
					</section>

					<section>
						<pre><code data-trim>
true
ok
						</code></pre>
					</section>
				</section>

				<section>
					<section>
						<h2>Structs</h2>
						<pre><code data-trim>
package main

import "fmt"

type Vertex struct {
	X, Y int
}

func main() {
	p := Vertex{1, 2}  // has type Vertex
	q := &Vertex{1, 2} // has type *Vertex
	r := Vertex{X: 1}  // Y:0 is implicit
	s := Vertex{}      // X:0 and Y:0

	fmt.Println(p, q, r, s)
}


						</code></pre>
					</section>

					<section>
						<pre><code data-trim>
{1 2} &{1 2} {1 0} {0 0}
						</code></pre>
					</section>
				</section>

				<section>
					<section>
						<h2>Pointers</h2>
						<ul>
							<li>Go has pointers, but no pointer arithmetic.</li>
							<li>The indirection through the pointer is transparent.</li>
							<li>By default Go passes arguments by values (copying the arguments).</li>
							<li>To get the pointer of a value, use the &amp; symbol in front of the value.</li>
							<li>To dereference a pointer, use the * symbol.</li>
						</ul>
					</section>

					<section>
						<h2>Pointers</h2>
						<pre><code data-trim>
package main
import "fmt"

type Vertex struct {
	X, Y int
}

func main() {
	p := Vertex{1, 2}  // has type Vertex
	q := &Vertex{1, 2} // has type *Vertex
	p.X = 3
	p.Y = 4
	q.X = 8
	q.Y = 9

	fmt.Println(p, q)
}
						</code></pre>
					</section>

					<section>
						<pre><code data-trim>
{3 4} &{8 9}
						</code></pre>
					</section>

					<section>
						<h2>Pointers</h2>
						<pre><code data-trim>
package main

import (
	"fmt"
)

type Bootcamp struct {
	Lat float64
	Lon float64
}

func main() {
	x := new(Bootcamp) // new(), zeroed values
	y := &Bootcamp{}   // struct literal
	fmt.Println(*x == *y)
}

						</code></pre>
					</section>

					<section>
						<pre><code data-trim>
true
						</code></pre>
					</section>
				</section>

				<section>
					<section>
						<h2>Arrays</h2>
						<ul>
							<li>An arrayâ€™s length is part of its type.</li>
							<li>Arrays cannot be resized.</li>
						</ul>
					</section>

					<section>
						<h2>Arrays</h2>
						<pre><code data-trim>
package main

import (
	"fmt"
	"reflect"
)

func main() {
	var a [2]string
	a[0] = "Hello"
	a[1] = "World"
	fmt.Println(a[0], a[1])
	fmt.Println(a)
	fmt.Println(reflect.TypeOf(a))
}

						</code></pre>
					</section>

					<section>
						<pre><code data-trim>
Hello World
[Hello World]
[2]string
						</code></pre>
					</section>

					<section>
						<h2>Arrays</h2>
						<pre><code data-trim>
package main

import (
	"fmt"
	"reflect"
)

func main() {
	a := [2]string{"hello", "world!"}
	b := [...]string{"hello", "world", "again"}
	fmt.Println(a)
	fmt.Println(b)
	fmt.Println(reflect.TypeOf(a))
	fmt.Println(reflect.TypeOf(b))
	fmt.Println(len(a))
	fmt.Println(len(b))
}

						</code></pre>
					</section>

					<section>
						<pre><code data-trim>
[hello world!]
[hello world again]
[2]string
[3]string
2
3
						</code></pre>
					</section>

					<section>
						<h2>Arrays</h2>
						<pre><code data-trim>
package main

import "fmt"

func main() {
	var a [2][3]string
	for i := 0; i < 2; i++ {
		for j := 0; j < 3; j++ {
			a[i][j] = fmt.Sprintf("row %d - column %d", i+1, j+1)
		}
	}
	fmt.Printf("%q", a)
}

						</code></pre>
					</section>

					<section>
						<pre><code data-trim>
[["row 1 - column 1" "row 1 - column 2" "row 1 - column 3"] ["row 2 - column 1" "row 2 - column 2" "row 2 - column 3"]]
						</code></pre>
					</section>

				</section>

				<section>
					<section>
						<h2>Slices</h2>
						<ul>
							<li>Slices wrap arrays to give a more general interfaces to sequences.</li>
							<li>Most array programming in Go is done with slices rather than simple arrays.</li>
							<li>Slices hold references to an underlying array, and if you assign one slice to another, both refer to the same array.</li>
							<li>Slices can be resized since they are just a wrapper on top of another data structure.</li>
						</ul>
					</section>

					<section>
						<h2>Slices</h2>
						<pre><code data-trim>
package main

import (
	"fmt"
	"reflect"
)

func main() {
	p := []int{2, 3}
	fmt.Println(p)
	fmt.Println(reflect.TypeOf(p))
}


						</code></pre>
					</section>

					<section>
						<pre><code data-trim>
[2 3]
[]int
						</code></pre>
					</section>

					<section>
						<h2>Slices</h2>
						<pre><code data-trim>
package main

import "fmt"

func main() {
	cities := make([]string, 3)
	cities[0] = "Santa Monica"
	cities[1] = "Venice"
	cities[2] = "Los Angeles"
	fmt.Printf("%q\n", cities)

	cities2 := []string{}
	cities2 = append(cities2, "San Diego")
	fmt.Printf("%q", cities2)
}


						</code></pre>
					</section>

					<section>
						<pre><code data-trim>
["Santa Monica" "Venice" "Los Angeles"]
["San Diego"]
						</code></pre>
					</section>

				</section>

				<section>
					<section>
						<h2>Maps</h2>
						<ul>
							<li>Similar to hashes or dictionaries.</li>
							<li>When not using map literals like above, maps must be created with make (not new) before use.</li>
						</ul>
					</section>

					<section>
						<h2>Maps</h2>
						<pre><code data-trim>
package main

import "fmt"
import "reflect"

func main() {
	celebs := map[string]int{
		"Nicolas Cage":       50,
		"Selena Gomez":       21,
		"Jude Law":           41,
		"Scarlett Johansson": 29,
	}

	fmt.Printf("%#v\n", celebs)
	fmt.Println(reflect.TypeOf(celebs))
}

						</code></pre>
					</section>

					<section>
						<pre><code data-trim>
map[string]int{"Nicolas Cage":50, "Selena Gomez":21, "Jude Law":41, "Scarlett Johansson":29}
map[string]int
						</code></pre>
					</section>

					<section>
						<h2>Maps</h2>
						<pre><code data-trim>
package main

import "fmt"

type Vertex struct {
	Lat, Long float64
}

var m map[string]Vertex

func main() {
	m = make(map[string]Vertex)
	m["Bell Labs"] = Vertex{40.68433, -74.39967}
	fmt.Println(m["Bell Labs"])
	delete(m, "Bell Labs")
	fmt.Println(m["Bell Labs"])
	elem, ok := m["Bell Labs"]
	fmt.Println(elem, ok)
}


						</code></pre>
					</section>

					<section>
						<pre><code data-trim>
{40.68433 -74.39967}
{0 0}
{0 0} false
						</code></pre>
					</section>

				</section>

				<section data-background="#4d7e65">
					<section>
						<h2>Methods</h2>
						<ul>
							<li>Go does not have classes. However, you can define methods on struct types.</li>
							<li>A method is a function that has a defined receiver.</li>
							<li>The method receiver appears in its own argument list between the func keyword and the method name.</li>
						</ul>
					</section>

					<section>
						<h2>Methods</h2>
						<pre><code data-trim>
package main

import "fmt"

type User struct {
	FirstName, LastName string
}

func (u User) Greeting() string {
	return fmt.Sprintf("Dear %s %s", u.FirstName, u.LastName)
}

func main() {
	u := User{"Donny", "Kurniawan"}
	fmt.Println(u.Greeting())
}


						</code></pre>
					</section>

					<section>
						<pre><code data-trim>
Dear Donny Kurniawan
						</code></pre>
					</section>

					<section>
						<h2>Methods</h2>
						<ul>
							<li>Methods are defined outside of the struct.</li>
							<li>You can define a method on any type you define in your package, not just structs.</li>
							<li>You cannot define a method on a type from another package, or on a basic type.</li>
						</ul>
					</section>

					<section>
						<h2>Methods</h2>
						<pre><code data-trim>
package main

import (
	"fmt"
	"math"
)

type Vertex struct {
	X, Y float64
}

func (v *Vertex) Scale(f float64) {
	v.X = v.X * f
	v.Y = v.Y * f
}

func (v *Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func main() {
	v := &Vertex{3, 4}
	v.Scale(5)
	fmt.Println(v, v.Abs())
}


						</code></pre>
					</section>

					<section>
						<pre><code data-trim>
&{15 20} 25
						</code></pre>
					</section>

				</section>

				<section data-background="#4d7e65">
					<section>
						<h2>Interfaces</h2>
						<ul>
							<li>An interface type is defined by a set of methods.</li>
							<li>A value of interface type can hold any value that implements those methods.</li>
							<li>The method receiver appears in its own argument list between the func keyword and the method name.</li>
						</ul>
					</section>

					<section>
						<h2>Interfaces</h2>
						<pre><code data-trim>
package main

import (
	"fmt"
)

type User struct {
	FirstName, LastName string
}

func (u *User) Name() string {
	return fmt.Sprintf("%s %s", u.FirstName, u.LastName)
}

type Namer interface {
	Name() string
}

func Greet(n Namer) string {
	return fmt.Sprintf("Dear %s", n.Name())
}

func main() {
	u := &User{"Matt", "Damon"}
	fmt.Println(Greet(u))
}


						</code></pre>
					</section>

					<section>
						<pre><code data-trim>
Dear Matt Damon
						</code></pre>
					</section>

					<section>
						<h2>Interfaces</h2>
						<pre><code data-trim>
package main

import (
	"fmt"
)

type User struct {
	FirstName, LastName string
}

func (u *User) Name() string {
	return fmt.Sprintf("%s %s", u.FirstName, u.LastName)
}

type Customer struct {
	Id       int
	FullName string
}

func (c *Customer) Name() string {
	return c.FullName
}

type Namer interface {
	Name() string
}

func Greet(n Namer) string {
	return fmt.Sprintf("Dear %s", n.Name())
}

func main() {
	u := &User{"Matt", "Damon"}
	fmt.Println(Greet(u))
	c := &Customer{42, "Customer"}
	fmt.Println(Greet(c))
}


						</code></pre>
					</section>

					<section>
						<pre><code data-trim>
Dear Matt Damon
Dear Customer
						</code></pre>
					</section>

					<section>
						<h2>Interfaces</h2>
						<ul>
							<li>A type implements an interface by implementing the methods.</li>
							<li>There is no explicit declaration of intent.</li>
							<li>You cannot define a method on a type from another package, or on a basic type.</li>
						</ul>
					</section>

				</section>

				<section data-background="#4d7e65">
					<section>
						<h2>Composition</h2>
						<ul>
							<li>Coming from an OOP background a lot of us are used to inheritance.</li>
							<li>Need to think in terms of composition and interfaces.</li>
							<li>Go supports implicit composition.</li>
						</ul>
					</section>

					<section>
						<h2>Composition</h2>
						<pre><code data-trim>
package main

import (
	"log"
	"os"
)

type Job struct {
	Command string
	Logger  *log.Logger
}

func main() {
	job := &Job{"demo", log.New(os.Stderr, "Job: ", log.Ldate)}
	// same as
	// job := &Job{Command: "demo", Logger: log.New(os.Stderr, "Job: ", log.Ldate)}
	job.Logger.Print("test")
}

						</code></pre>
					</section>

					<section>
						<pre><code data-trim>
Job: 2014/05/28 test
						</code></pre>
					</section>

					<section>
						<h2>Composition</h2>
						<pre><code data-trim>
package main

import (
	"log"
	"os"
)

type Job struct {
	Command string
	*log.Logger
}

func main() {
	job := &Job{"demo", log.New(os.Stderr, "Job: ", log.Ldate)}
	job.Print("starting now...")
}

						</code></pre>
					</section>

					<section>
						<pre><code data-trim>
Job: 2014/05/28 starting now...
						</code></pre>
					</section>

				</section>

				<section data-background="#8c4738">
					<section>
						<h2>Concurrency</h2>
						<ul>
							<li>Made difficult by the subtleties required to implement correct access to shared variables.</li>
							<li>Shared values are passed around on channels and, in fact, never actively shared by separate threads of execution.</li>
							<li>Only one goroutine has access to the value at any given time.</li>
							<li>Data races cannot occur, by design.</li>
						</ul>
					</section>

					<section>
						<h3>Do not communicate by sharing memory; <br/>instead, share memory by communicating.</h3>
					</section>
				</section>

				<section data-background="#8c4738">
					<section>
						<h2>Goroutines</h2>
						<ul>
							<li>A goroutine is a lightweight thread managed by the Go runtime.</li>
							<li><code>go f(x, y, z)</code> starts a new goroutine running <code>f(x, y, z)</code>.</li>
							<li>The evaluation of <code>f, x, y, z</code> happens in the current goroutine and the execution of <code>f</code> happens in the new goroutine.</li>
						</ul>
					</section>

					<section>
						<h2>Goroutines</h2>
						<pre><code data-trim>
package main

import (
	"fmt"
	"time"
)

func say(s string) {
	for i := 0; i < 2; i++ {
		time.Sleep(100 * time.Millisecond)
		fmt.Println(s)
	}
}

func main() {
	go say("world")
	say("hello")
}

						</code></pre>
					</section>

					<section>
						<pre><code data-trim>
hello
world
hello
						</code></pre>
					</section>

				</section>


				<section data-background="#8c4738">
					<section>
						<h2>Channels</h2>
						<ul>
							<li>Channels are a typed conduit through which you can send and receive values with the channel operator, <code><-</code>.</li>
							<li><code>ch <- v</code>, sends v to channel ch.</li>
							<li><code>v := <-ch</code>, receives from ch and assign value to v.</li>
							<li>Must be created before use, <code>ch := make(chan int)</code>.</li>
							<li>By default, sends and receives block until the other side is ready. This allows goroutines to synchronize without explicit locks or condition variables.</li>
						</ul>
					</section>

					<section>
						<h2>Channels</h2>
						<pre><code data-trim>
package main

import "fmt"

func sum(a []int, c chan int) {
	sum := 0
	for _, v := range a {
		sum += v
	}
	c <- sum // send sum to c
}

func main() {
	a := []int{7, 2, 8, -9, 4, 0}

	c := make(chan int)

	go sum(a[:len(a)/2], c)
	go sum(a[len(a)/2:], c)

	x, y := <-c, <-c // receive from c

	fmt.Println(x, y, x+y)
}
						</code></pre>
					</section>

					<section>
						<pre><code data-trim>
17 -5 12
						</code></pre>
					</section>

					<section>
						<h2>Channels</h2>
						<ul>
							<li>Channels can be buffered.</li>
							<li>Sends to a buffered channel block only when the buffer is full.</li>
							<li>Receives block when the buffer is empty.</li>
						</ul>
					</section>

					<section>
						<h2>Channels</h2>
						<pre><code data-trim>
package main

import "fmt"

func main() {
    c := make(chan int, 2)
    c <- 1
    c <- 2
    fmt.Println(<-c)
    fmt.Println(<-c)
}
						</code></pre>
					</section>

					<section>
						<pre><code data-trim>
1
2
						</code></pre>
					</section>

					<section>
						<h2>Channels</h2>
						<pre><code data-trim>
package main

import "fmt"

func main() {
	c := make(chan int, 2)
	c <- 1
	c <- 2
	c <- 3
	fmt.Println(<-c)
	fmt.Println(<-c)
	fmt.Println(<-c)
}
						</code></pre>
					</section>

					<section>
						<pre><code data-trim>
fatal error: all goroutines are asleep - deadlock!
						</code></pre>
					</section>

					<section>
						<h2>Channels</h2>
						<pre><code data-trim>
package main

import "fmt"

func main() {
	c := make(chan int, 2)
	c <- 1
	c <- 2
	c3 := func() { c <- 3 }
	go c3()
	fmt.Println(<-c)
	fmt.Println(<-c)
    fmt.Println(<-c)
}
						</code></pre>
					</section>

					<section>
						<pre><code data-trim>
1
2
3
						</code></pre>
					</section>

				</section>


				<section data-background="#8c4738">
					<section>
						<h2>Select</h2>
						<ul>
							<li>It lets a goroutine wait on multiple communication operations.</li>
							<li>A select blocks until one of its cases can run, then it executes that case.</li>
							<li>It chooses one at random if multiple are ready.</li>
						</ul>
					</section>

					<section>
						<h2>Select</h2>
						<pre><code data-trim>
package main

import "fmt"

func fibonacci(c, quit chan int) {
	x, y := 0, 1
	for {
		select {
		case c <- x:
			x, y = y, x+y
		case <-quit:
			fmt.Println("quit")
			return
		}
	}
}

func main() {
	c := make(chan int)
	quit := make(chan int)

	go func() {
		for i := 0; i < 10; i++ {
			fmt.Println(<-c)
		}
		
		quit <- 0
	}()

	fibonacci(c, quit)
}


						</code></pre>
					</section>

					<section>
						<pre><code data-trim>
0
1
1
2
3
5
8
13
21
34
quit
						</code></pre>
					</section>

				</section>


				<section>
					<section>
						<h2>Resources</h2>
						<ul>
							<li>http://golang.org</li>
							<li>http://play.golang.org</li>
							<li>http://www.golangbootcamp.com</li>
							<li>http://dave.cheney.net/resources-for-new-go-programmers</li>
						</ul>
					</section>

				</section>

				<section>
					<h1>THE END</h1>
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
